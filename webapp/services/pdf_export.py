"""
PDF Export Service

Generates professional PDF documents from conversations, BAS reviews,
and compliance summaries using Jinja2 templates and WeasyPrint.
"""

import logging
from datetime import datetime

from flask import render_template_string

from webapp.time_utils import utcnow

logger = logging.getLogger(__name__)

# PDF templates are rendered via Jinja2 then converted to PDF
PDF_BASE_CSS = """
@page {
    size: A4;
    margin: 2cm;
    @bottom-center {
        content: "Page " counter(page) " of " counter(pages);
        font-size: 9pt;
        color: #666;
    }
}
body {
    font-family: 'Helvetica', 'Arial', sans-serif;
    font-size: 11pt;
    line-height: 1.5;
    color: #333;
}
.header {
    border-bottom: 2px solid #0066CC;
    padding-bottom: 10px;
    margin-bottom: 20px;
}
.header h1 {
    color: #0066CC;
    font-size: 18pt;
    margin: 0;
}
.header .subtitle {
    color: #666;
    font-size: 10pt;
}
.message {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 5px;
}
.message.user {
    background-color: #f0f7ff;
    border-left: 3px solid #0066CC;
}
.message.assistant {
    background-color: #f5f5f5;
    border-left: 3px solid #00A67D;
}
.message .role {
    font-weight: bold;
    font-size: 10pt;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 5px;
}
.skills-used {
    background-color: #fff8e1;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 9pt;
    margin-top: 5px;
}
.summary-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
}
.summary-table th, .summary-table td {
    border: 1px solid #ddd;
    padding: 8px 12px;
    text-align: left;
}
.summary-table th {
    background-color: #0066CC;
    color: white;
    font-size: 10pt;
}
.summary-table tr:nth-child(even) {
    background-color: #f9f9f9;
}
.footer {
    margin-top: 30px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
    font-size: 9pt;
    color: #888;
}
.token-usage {
    font-size: 9pt;
    color: #888;
    margin-top: 3px;
}
"""

CONVERSATION_TEMPLATE = """
<!DOCTYPE html>
<html>
<head><style>{{ css }}</style></head>
<body>
<div class="header">
    <h1>{{ title }}</h1>
    <div class="subtitle">
        {% if business_name %}{{ business_name }} | {% endif %}
        Exported {{ export_date }} | Conversation ID: {{ conversation_id[:8] }}...
    </div>
</div>
{% for msg in messages %}
<div class="message {{ msg.role }}">
    <div class="role">{{ msg.role }}</div>
    <div>{{ msg.content }}</div>
    {% if msg.skills_used %}
    <div class="skills-used">Skills: {{ msg.skills_used | join(', ') }}</div>
    {% endif %}
    {% if msg.input_tokens or msg.output_tokens %}
    <div class="token-usage">Tokens: {{ msg.input_tokens }} in / {{ msg.output_tokens }} out</div>
    {% endif %}
</div>
{% endfor %}
<div class="footer">
    Generated by BAS Reviewer | {{ export_date }}
</div>
</body>
</html>
"""

COMPLIANCE_SUMMARY_TEMPLATE = """
<!DOCTYPE html>
<html>
<head><style>{{ css }}</style></head>
<body>
<div class="header">
    <h1>Compliance Summary Report</h1>
    <div class="subtitle">
        {% if business_name %}{{ business_name }} | {% endif %}
        Period: {{ date_from }} to {{ date_to }} | Exported {{ export_date }}
    </div>
</div>
<h2>Conversations Summary</h2>
<table class="summary-table">
    <thead>
        <tr>
            <th>Date</th>
            <th>Title</th>
            <th>Messages</th>
            <th>Skills Used</th>
            <th>Tokens</th>
        </tr>
    </thead>
    <tbody>
    {% for conv in conversations %}
        <tr>
            <td>{{ conv.created_at[:10] if conv.created_at else 'N/A' }}</td>
            <td>{{ conv.title or 'Untitled' }}</td>
            <td>{{ conv.message_count }}</td>
            <td>{{ conv.skills | join(', ') if conv.skills else '-' }}</td>
            <td>{{ conv.total_tokens }}</td>
        </tr>
    {% endfor %}
    </tbody>
</table>
<h2>Totals</h2>
<p>Total conversations: {{ conversations | length }}</p>
<p>Total tokens used: {{ total_tokens }}</p>
<div class="footer">
    Generated by BAS Reviewer | {{ export_date }}
</div>
</body>
</html>
"""


def export_conversation(conversation_id: str, business_name: str = "") -> bytes:
    """
    Export a single conversation as PDF bytes.

    Args:
        conversation_id: The conversation ID to export
        business_name: Optional business name for header

    Returns:
        PDF file as bytes
    """
    from webapp.models import Conversation, Message, db

    conversation = db.session.get(Conversation, conversation_id)
    if not conversation:
        raise ValueError(f"Conversation {conversation_id} not found")

    messages = [
        msg.to_dict()
        for msg in Message.query.filter_by(conversation_id=conversation.id)
        .order_by(Message.created_at)
        .all()
    ]

    html = render_template_string(
        CONVERSATION_TEMPLATE,
        css=PDF_BASE_CSS,
        title=conversation.title or "Conversation Export",
        business_name=business_name,
        export_date=utcnow().strftime("%d %b %Y %H:%M UTC"),
        conversation_id=conversation.id,
        messages=messages,
    )

    try:
        from weasyprint import HTML

        pdf_bytes = HTML(string=html).write_pdf()
    except (ImportError, OSError):
        logger.warning("WeasyPrint not available, returning HTML as fallback")
        pdf_bytes = html.encode("utf-8")

    return pdf_bytes  # type: ignore[no-any-return]


def export_compliance_summary(
    team_id: str,
    date_from: str | None = None,
    date_to: str | None = None,
    business_name: str = "",
) -> bytes:
    """
    Export a compliance summary PDF for a team over a date range.

    Args:
        team_id: Team ID
        date_from: Start date (YYYY-MM-DD)
        date_to: End date (YYYY-MM-DD)
        business_name: Optional business name

    Returns:
        PDF file as bytes
    """
    from webapp.models import Conversation, User

    query = Conversation.query.join(User, Conversation.user_id == User.id).filter(
        User.team_id == team_id
    )

    if date_from:
        query = query.filter(
            Conversation.created_at >= datetime.strptime(date_from, "%Y-%m-%d")
        )
    if date_to:
        query = query.filter(
            Conversation.created_at
            <= datetime.strptime(date_to, "%Y-%m-%d").replace(
                hour=23, minute=59, second=59
            )
        )

    conversations_data = []
    total_tokens = 0
    for conv in query.order_by(Conversation.created_at.desc()).all():
        msgs = conv.messages.all()
        skills = set()
        conv_tokens = 0
        for m in msgs:
            conv_tokens += (m.input_tokens or 0) + (m.output_tokens or 0)
            if m.skills_used:
                skills.update(m.skills_used)
        total_tokens += conv_tokens
        conversations_data.append(
            {
                "created_at": conv.created_at.isoformat() if conv.created_at else None,
                "title": conv.title,
                "message_count": len(msgs),
                "skills": sorted(skills),
                "total_tokens": conv_tokens,
            }
        )

    html = render_template_string(
        COMPLIANCE_SUMMARY_TEMPLATE,
        css=PDF_BASE_CSS,
        business_name=business_name,
        date_from=date_from or "Beginning",
        date_to=date_to or "Present",
        export_date=utcnow().strftime("%d %b %Y %H:%M UTC"),
        conversations=conversations_data,
        total_tokens=total_tokens,
    )

    try:
        from weasyprint import HTML

        pdf_bytes = HTML(string=html).write_pdf()
    except (ImportError, OSError):
        logger.warning("WeasyPrint not available, returning HTML as fallback")
        pdf_bytes = html.encode("utf-8")

    return pdf_bytes  # type: ignore[no-any-return]


def export_bulk_conversations(
    conversation_ids: list[str], business_name: str = ""
) -> bytes:
    """
    Export multiple conversations into a single PDF.

    Args:
        conversation_ids: List of conversation IDs
        business_name: Optional business name

    Returns:
        PDF file as bytes
    """
    from webapp.models import Conversation, Message, db

    all_sections = []
    for cid in conversation_ids:
        conversation = db.session.get(Conversation, cid)
        if not conversation:
            continue

        messages = [
            msg.to_dict()
            for msg in Message.query.filter_by(conversation_id=conversation.id)
            .order_by(Message.created_at)
            .all()
        ]

        all_sections.append(
            {
                "title": conversation.title or "Untitled",
                "conversation_id": conversation.id,
                "messages": messages,
            }
        )

    bulk_template = """
    <!DOCTYPE html>
    <html>
    <head><style>{{ css }}
    .page-break { page-break-before: always; }
    </style></head>
    <body>
    <div class="header">
        <h1>Bulk Conversation Export</h1>
        <div class="subtitle">
            {% if business_name %}{{ business_name }} | {% endif %}
            {{ sections | length }} conversations | Exported {{ export_date }}
        </div>
    </div>
    {% for section in sections %}
    {% if not loop.first %}<div class="page-break"></div>{% endif %}
    <h2>{{ section.title }}</h2>
    <p style="font-size:9pt;color:#888;">ID: {{ section.conversation_id[:8] }}...</p>
    {% for msg in section.messages %}
    <div class="message {{ msg.role }}">
        <div class="role">{{ msg.role }}</div>
        <div>{{ msg.content }}</div>
    </div>
    {% endfor %}
    {% endfor %}
    <div class="footer">
        Generated by BAS Reviewer | {{ export_date }}
    </div>
    </body>
    </html>
    """

    html = render_template_string(
        bulk_template,
        css=PDF_BASE_CSS,
        business_name=business_name,
        export_date=utcnow().strftime("%d %b %Y %H:%M UTC"),
        sections=all_sections,
    )

    try:
        from weasyprint import HTML

        pdf_bytes = HTML(string=html).write_pdf()
    except (ImportError, OSError):
        logger.warning("WeasyPrint not available, returning HTML as fallback")
        pdf_bytes = html.encode("utf-8")

    return pdf_bytes  # type: ignore[no-any-return]
